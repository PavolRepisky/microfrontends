\section{Microfrontends Tradeoffs}
This section lists the most frequently mentioned advantages and disadvantages of microfrontends in the literature.

\subsection{Advantages}
There are numerous reasons why large companies are adopting microfrontend architecture, but the most prominent one is the increased development speed and reduced time to market due to cross-functional teams \cite{Geers, Montelius, Peltonen}. Geers \cite{Geers} mentions: ``Reducing waiting time between teams is microfrontends' primary goal.'' Having all developers working on the same stack within a single team leads to fewer misunderstandings and much faster communication \cite{Geers, Montelius}. Additionally, teams have much more freedom to make case-by-case decisions regarding individual parts of the product \cite{Jackson, Geers}, allowing them to become experts in their respective areas of the application \cite{Montelius}.

Microfrontends also bring many of the benefits of microservices architecture to the frontend. The codebases are smaller, more understandable, and less complex \cite{Geers, Jackson, Montelius}. Consequently, this can lead to shorter onboarding times for new developers \cite{Peltonen}. Each microfrontend is isolated, independently deployable, and its failure does not affect the rest of the system \cite{Peltonen, Montelius, Jackson, Geers}.

Microfrontends encourage changes and experimentation with new technologies, which is especially important in the frontend space, where technologies evolve rapidly. Microfrontends provide a way to upgrade only specific parts of the application instead of rewriting the entire system at once \cite{Jackson, Montelius}, and each microfrontend can potentially be developed using different technologies. This encourages developers to experiment with new tools and quickly adapt to changing requirements \cite{Peltonen}.

\subsection{Disadvantages}
However, microfrontends are not a silver bullet. Having an application split into multiple parts across multiple teams, potentially using different technologies, naturally introduces a lot of redundancy. The redundancy can be in terms of actual code, where multiple teams implement the same functionality repeatedly, but also in terms of common dependencies, which, if not handled properly, will be included in multiple microfrontends. Furthermore, if teams are using different technologies or even just different versions, they must all be bundled individually \cite{Geers, Peltonen}. This all leads to a larger payload size, with the browser having to fetch more data, which can negatively affect the performance of the application \cite{Peltonen, Montelius, Jackson}. Each team also needs to set up and maintain its own application server, build processes, and CI/CD pipelines.

As already mentioned in the challenges section \ref{sec:MicrofrontendsChallenges}, this architecture also complicates otherwise well-established techniques such as routing, communication, static asset serving, and styling, requiring them to be handled in a specialized way.

Microfrontends can potentially add a lot of unnecessary complexity at both the technical and organizational levels \cite{Peltonen}. They require a significant amount of knowledge and analysis about a project before development begins \cite{Montelius, Peltonen}. There are risks associated with developing in a standalone environment that is quite different from production, requiring extensive integration testing \cite{Jackson, Montelius, Peltonen}. This differs from microservices, as they do not need to be integrated into a single application. Lastly, microfrontends could potentially lead to varying code quality if requirements are not clearly defined across all teams \cite{Montelius}.