\subsection{Monolithic applications}
Monolithic architecture is one of the oldest and most traditional web architectures. In this architecture, all required components are tightly coupled within a single, unified system that operates independently of other applications. It integrates all business concerns into one structure. All components are dependent on each other and usually cannot run or even compile independently. The system traditionally uses a single shared database. From the operating system's point of view, a monolithic application runs as a single process within the application server's environment. Monolithic applications can be scaled up by running multiple instances behind a load balancer. Examples of technologies commonly used to build monolithic applications are Spring Boot, Ruby on Rails or Laravel.\\

\noindent
The most significant advantage of this architecture is its simplicity. Since it runs as a single process, it is much easier to test, deploy, debug, and monitor. The project configuration and setup are quick and straightforward. All data is stored in a single database, eliminating the need for synchronization. All communication occurs via intra-process mechanisms, which avoids delays and other communication problems, typically resulting in better performance. It is also cheaper to host the application. \\

\noindent
However, as the company grows, so does the monolithic application. It eventually becomes so large that few, if any, people fully understand how the entire application works. This leads to slower development processes and a higher likelihood of bugs. Changes in one components may cause unexpected behavior in parts of the system, resulting in a cascade of errors and a failure of a single component impacts the entire system. Developers must choose a technology at the start and are essentially locked into it for the application's lifetime, as switching technologies would require a complete rewrite of the application. When changes are made to any part of the application, it is necessary to rebuild and redeploy the entire application. Due to their size, monoliths often have longer startup times. As the application grows, the number of developers increases, often leading to unequal workforce utilization and productivity losses. \\

\noindent
Therefore, monolithic applications are best suited for smaller, less complex applications that do not anticipate frequent code changes or evolving requirements. Examples of these are content-based websites. \cite{Salaheddin}\cite{Blinowski}