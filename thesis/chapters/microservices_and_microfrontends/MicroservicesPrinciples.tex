\section{Microservices Principles}
This section summarizes the basic principles of microservices architecture based on Martin Fowler's article \cite{Fowler}.

\subsection{Componentize via Services}
The primary way of componentizing microservices applications is by breaking them down into services. Applications built this way aim to be as decoupled and cohesive as possible, where each service acts more like a filter in the Unix sense—receiving a request, applying some logic, and producing a response. The services communicate using REST protocols or a lightweight message bus. For this to work in practice, we must create a loosely coupled system where one service knows very little or nothing about the others. This combination of related logic into a single unit is known as cohesion. The higher the cohesion, the better the microservice architecture.

\subsection{Model Around Business Domain}
Traditionally, applications were split into technical layers such as the Presentation Layer, Business Layer, and Data Access Layer, with each of these layers being managed as a separate service by its own team. The problem with this approach is that making even a small change often cascades across multiple layers and teams, resulting in several deployments. This challenge worsens as more layers are added. This is known as horizontal decomposition. In contrast, vertical decomposition focuses on finding service boundaries that align with business domains. This results in services with names reflecting the system's functionalities and exposing the capabilities that customers need. Therefore, changes related to a specific business domain tend to affect only the corresponding service boundary rather than multiple services. The team owning the service becomes an expert in that domain. Additionally, this approach ensures loose coupling between services and enhances team autonomy.

\subsection{Design for Failure}
Microservices aim to enhance the fault tolerance and resilience of an application by isolating services to prevent the failure of one service from cascading to others. Microservices should be designed with the assumption that any service can fail at any time. To ensure this, different patterns are utilized, such as the circuit breaker pattern. If a microservice fails repeatedly, the circuit breaker pattern allows the system to temporarily cut off communication with the problematic service, thereby preventing repeated communication attempts with the failing service and avoiding potential performance issues and application-wide failures. This enables other services to function properly without disruption, improving overall system resilience.

\subsection{Adopt a Culture of Automation}
Microservices add a lot of additional complexity because of the number of different moving pieces. Embracing a culture of automation is one way to address this, and front-loading effort to create automation tooling makes a lot of sense. One such tool is automated testing at various levels (unit, integration, end-to-end) to ensure code quality is maintained. Another key aspect of automation is continuous integration and continuous deployment (CI/CD), where code changes are automatically built, tested, and deployed to production. Infrastructure as Code (IaC) is another important aspect. It enables teams to define and manage infrastructure via code, ensuring that environments are consistent, easily reproducible, and scalable. Automation enhances productivity, speeds up development, minimizes errors, and frees teams from repetitive tasks.

\subsection{Decentralize Everything}
One of the problems with centralized governance is the tendency to standardize on a single technology, which may not be the best fit for every problem, as there may be better choices available. Microservices aim to avoid this by encouraging developers to use different technologies and frameworks based on what they believe will be the best tool for a given service. Each service typically also manages its own data storage, whether through different instances of the same technology or entirely different systems. Teams take complete ownership of their services through decentralized decision-making, becoming domain experts in both the service and the related business domain they are supporting. By decentralizing everything—from decision-making and development to infrastructure and data management—we create systems that are more scalable, resilient, and adaptable.

\subsection{Evolve Continuously}
Microservices embrace the idea that software systems should keep evolving to meet new requirements, technologies, and business needs. This aligns well with the architecture, as each service is built and deployed independently and therefore can evolve at its own pace without requiring redesigns of the entire system. Additionally, new features can be added and plugged in as completely new services. This allows organizations to adapt quickly to changing requirements and grow with the needs of the business, ensuring long-term sustainability.